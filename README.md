#### 1. Tomcat 서버를 시작할 때 웹 애플리케이션이 초기화하는 과정을 설명하라.
* 서블릿 컨테이너는 웹 어플리케이션의 상태를 관리하는 ServletContext를 생성
* ServletContext가 초기화 될 시 컨텍스트 초기화 이벤트 발생
* 등록된 ServletContentListener의 콜백 메소드 호출
* jsp.sql의 sql문 실행하여 데이터베이스 초기화
* 서블릿 컨테이너는 클라이언트 최초 요청시 DispatcherServlet 생성


#### 2. Tomcat 서버를 시작한 후 http://localhost:8080으로 접근시 호출 순서 및 흐름을 설명하라.
* 서블릿 접근 전에 먼저 ResourceFilter와 characterEncodingFilter의 DoFilter 메소드가 먼저 실행
* 요청 처리는 /으로 mapping된 DispatcherServlet의 service() 실행
* 요청받은 URL을 분석해 해당 controller 객체를 RequestMapping에서 가져온다.
* service 메소드는 위임한 controller의 구현체의 execute()에서 실질적인 작업이 이루어진다.
* 그 반환 값은 ModelAndView이다.
* ModelAndView의 모델 데이터를 뷰의 render 메소드에 전달한다. 

#### 7. next.web.qna package의 ShowController는 멀티 쓰레드 상황에서 문제가 발생하는 이유에 대해 설명하라.
* 아래의 a는 포인터로 참조된 값으로 봐주면 될 것 같습니다. 오해가 생긴 이유가 그거인듯! 즉 멀티스레드가 같은 메모리주소의 a의 값을 바라보고 있다고 가정해야 합니다. java로 치면 싱글턴 인스턴스거나 같은 객체를 공유하는 경우가 될 것 같습니다.
* 지역변수라면 각 스레드가 다른 스택프레임을 바라보고 있고 그 안에 메모리 주소가 위치하기 때문에 무관합니다.
* 문제가 생길 것 같습니다. 결국 동시성 문제의 핵심은

*  a += 3;
* 코드로는 한 줄이지만 이는 사실 어셈블리 단에서는 a가 저장된 메모리에서 3의 값을 참조하여 레지스터로 가져오고 해당 값을 cpu에서 더해주고 다시 레지스터에서 메모리로 옮겨주는 여러 인스트럭션으로 나뉜다.
*  메모리에서 레지스터에 옮겨와서(mov) op을 (add) 수행한다.
*  옮겨온 값에 대해 op을 수행하는 동안 다른 스레드가 해당 메모리값을 동시에 참조할 가능성이 있다. 아직 op을 수행하고 그 뒤에 다시 메모리로 옮겨주는 mov는 수행되지 않았다. 사실 이건 멀티스레드라면 언제 수행될 지도 알 수 없다. ㅜ
* 수정된 값 이후를 참조해야되는데 이런! 수정되기 전의 메모리 값을 참조해버렸습니다!
* 서로 다른 값을 참조한다고 해도 완전히 thread-safe하지는 않습니다. 사실 이건 list에서도 마찬가지인데
* 예를 들어 2, 3번째 index의 list를 동시에 참조하고 삭제한다고 생각해보면 어떤 문제가 일어날지 생각해보면 될 것 같습니다.
